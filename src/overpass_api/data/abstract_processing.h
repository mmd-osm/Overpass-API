/** Copyright 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018 Roland Olbricht et al.
 *
 * This file is part of Overpass_API.
 *
 * Overpass_API is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * Overpass_API is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Overpass_API.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef DE__OSM3S___OVERPASS_API__DATA__ABSTRACT_PROCESSING_H
#define DE__OSM3S___OVERPASS_API__DATA__ABSTRACT_PROCESSING_H

#include "../core/datatypes.h"
#include "../statements/statement.h"
#include "collect_items.h"
#include "filenames.h"

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <iterator>
#include <memory>
#include <type_traits>
#include <vector>


namespace experimental {

// Copyright notice for experimental namespace

/*

This file is part of Osmium (http://osmcode.org/libosmium).

Copyright 2013-2017 Jochen Topf <jochen@topf.org> and others (see README).

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/


  /**
   * Virtual parent class for IdSets. Use one of the implementations
   * provided.
   */
  template <typename T>
  class IdSet {

  public:

      IdSet() = default;

      IdSet(const IdSet&) = default;
      IdSet& operator=(const IdSet&) = default;

      IdSet(IdSet&&) noexcept = default;
      IdSet& operator=(IdSet&&) noexcept = default;

      virtual ~IdSet() = default;

      /**
       * Add the given Id to the set.
       */
      virtual void set(T id) = 0;

      /**
       * Is the Id in the set?
       */
      virtual bool get(T id) const noexcept = 0;

      /**
       * Is the set empty?
       */
      virtual bool empty() const = 0;

      /**
       * Clear the set.
       */
      virtual void clear() = 0;

      /**
       * Get an estimate of the amount of memory used for the set.
       */
      virtual std::size_t used_memory() const noexcept = 0;

  }; // class IdSet

  template <typename T, unsigned int L>
  class IdSetDense;

  /**
   * Const_iterator for iterating over a IdSetDense.
   */
  template <typename T, unsigned int L>
  class IdSetDenseIterator {

      static_assert(std::is_unsigned<T>::value, "Needs unsigned type");
      static_assert(sizeof(T) >= 4, "Needs at least 32bit type");

      const IdSetDense<T, L>* m_set;
      T m_value;
      T m_last;

      void next() noexcept {
          while (m_value != m_last && !m_set->get(m_value)) {
              const T cid = IdSetDense<T, L>::chunk_id(m_value);
              assert(cid < m_set->m_data.size());
              if (!m_set->m_data[cid]) {
                  m_value = (cid + 1) << (IdSetDense<T, L>::chunk_bits + 3);
              } else {
                  const auto slot = m_set->m_data[cid][IdSetDense<T, L>::offset(m_value)];
                  if (slot == 0) {
                      m_value += 8;
                      m_value &= ~0x7;
                  } else {
                      ++m_value;
                  }
              }
          }
      }

  public:

      using iterator_category = std::forward_iterator_tag;
      using value_type        = T;
      using pointer           = value_type*;
      using reference         = value_type&;

      IdSetDenseIterator(const IdSetDense<T, L>* set, T value, T last) noexcept :
          m_set(set),
          m_value(value),
          m_last(last) {
          next();
      }

      IdSetDenseIterator<T, L>& operator++() noexcept {
          if (m_value != m_last) {
              ++m_value;
              next();
          }
          return *this;
      }

      IdSetDenseIterator<T, L> operator++(int) noexcept {
          IdSetDenseIterator<T, L> tmp{*this};
          operator++();
          return tmp;
      }

      bool operator==(const IdSetDenseIterator<T, L>& rhs) const noexcept {
          return m_set == rhs.m_set && m_value == rhs.m_value;
      }

      bool operator!=(const IdSetDenseIterator<T, L>& rhs) const noexcept {
          return ! (*this == rhs);
      }

      T operator*() const noexcept {
          assert(m_value < m_last);
          return m_value;
      }

  }; // class IdSetDenseIterator

  /**
   * A set of Ids of the given type. Internal storage is in chunks of
   * arrays used as bit fields. Internally those chunks will be allocated
   * as needed, so it works relatively efficiently with both smaller
   * and larger Id sets. If it is not used, no memory is allocated at
   * all.
   */
  template <typename T, unsigned int L = 22>
  class IdSetDense : public IdSet<T> {

      static_assert(std::is_unsigned<T>::value, "Needs unsigned type");
      static_assert(sizeof(T) >= 4, "Needs at least 32bit type");

      friend class IdSetDenseIterator<T, L>;

      // This value is a compromise. For node Ids it could be bigger
      // which would mean less (but larger) memory allocations. For
      // relations Ids it could be smaller, because they would all fit
      // into a smaller allocation.
      constexpr static const std::size_t chunk_bits = L;
      constexpr static const std::size_t chunk_size = 1 << chunk_bits;

      std::vector<std::unique_ptr<unsigned char[]>> m_data;
      T m_size = 0;

      static std::size_t chunk_id(T id) noexcept {
          return id >> (chunk_bits + 3);
      }

      static std::size_t offset(T id) noexcept {
          return (id >> 3) & ((1 << chunk_bits) - 1);
      }

      static unsigned char bitmask(T id) noexcept {
          return 1 << (id & 0x7);
      }

      T last() const noexcept {
          return static_cast<T>(m_data.size()) * chunk_size * 8;
      }

      unsigned char& get_element(T id) {
          const auto cid = chunk_id(id);
          if (cid >= m_data.size()) {
              m_data.resize(cid + 1);
          }

          auto& chunk = m_data[cid];
          if (!chunk) {
              chunk.reset(new unsigned char[chunk_size]);
              ::memset(chunk.get(), 0, chunk_size);
          }

          return chunk[offset(id)];
      }

  public:

      using const_iterator = IdSetDenseIterator<T, L>;

      IdSetDense() = default;

      /**
       * Add the Id to the set if it is not already in there.
       *
       * @param id The Id to set.
       * @returns true if the Id was added, false if it was already set.
       */
      bool check_and_set(T id) {
          auto& element = get_element(id);

          if ((element & bitmask(id)) == 0) {
              element |= bitmask(id);
              ++m_size;
              return true;
          }

          return false;
      }

      /**
       * Add the given Id to the set.
       *
       * @param id The Id to set.
       */
      void set(T id) final {
          (void)check_and_set(id);
      }

      /**
       * Remove the given Id from the set.
       *
       * @param id The Id to set.
       */
      void unset(T id) {
          auto& element = get_element(id);

          if ((element & bitmask(id)) != 0) {
              element &= ~bitmask(id);
              --m_size;
          }
      }

      /**
       * Is the Id in the set?
       *
       * @param id The Id to check.
       */
      bool get(T id) const noexcept final {
          if (chunk_id(id) >= m_data.size()) {
              return false;
          }
          auto* r = m_data[chunk_id(id)].get();
          if (!r) {
              return false;
          }
          return (r[offset(id)] & bitmask(id)) != 0;
      }

      /**
       * Is the set empty?
       */
      bool empty() const noexcept final {
          return m_size == 0;
      }

      /**
       * The number of Ids stored in the set.
       */
      T size() const noexcept {
          return m_size;
      }

      /**
       * Clear the set.
       */
      void clear() final {
          m_data.clear();
          m_size = 0;
      }

      std::size_t used_memory() const noexcept final {
          return m_data.size() * chunk_size;
      }

      IdSetDenseIterator<T, L> begin() const {
          return {this, 0, last()};
      }

      IdSetDenseIterator<T, L> end() const {
          return {this, last(), last()};
      }

  }; // class IdSetDense


  /**
   * IdSet implementation for small Id sets. It writes the Ids
   * into a vector and uses linear search.
   */
  template <typename T>
  class IdSetSmall : public IdSet<T> {

      std::vector<T> m_data;

  public:

      /**
       * Add the given Id to the set.
       */
      void set(T id) final {
          m_data.push_back(id);
      }

      /**
       * Is the Id in the set? Uses linear search.
       *
       * @param id The Id to check.
       */
      bool get(T id) const noexcept final {
          const auto it = std::find(m_data.cbegin(), m_data.cend(), id);
          return it != m_data.cend();
      }

      /**
       * Is the Id in the set? Uses a binary search. For larger sets
       * this might be more efficient than calling get(), the set
       * must be sorted.
       *
       * @param id The Id to check.
       * @pre You must have called sort_unique() before calling this
       *      or be sure there are no duplicates and the Ids have been
       *      set in order.
       */
      bool get_binary_search(T id) const noexcept {
          return std::binary_search(m_data.cbegin(), m_data.cend(), id);
      }

      /**
       * Is the set empty?
       */
      bool empty() const noexcept final {
          return m_data.empty();
      }

      /**
       * Clear the set.
       */
      void clear() final {
          m_data.clear();
      }

      /**
       * Sort the internal vector and remove any duplicates. Call this
       * before using size(), get_binary_search() or using an iterator.
       */
      void sort_unique() {
          std::sort(m_data.begin(), m_data.end());
          const auto last = std::unique(m_data.begin(), m_data.end());
          m_data.erase(last, m_data.end());
      }

      /**
       * The number of Ids stored in the set.
       *
       * @pre You must have called sort_unique() before calling this
       *      or be sure there are no duplicates.
       */
      std::size_t size() const noexcept {
          return m_data.size();
      }

      std::size_t used_memory() const noexcept final {
          return m_data.capacity() * sizeof(T);
      }

      /// Iterator type. There is no non-const iterator.
      using const_iterator = typename std::vector<T>::const_iterator;

      const_iterator begin() const noexcept {
          return m_data.cbegin();
      }

      const_iterator end() const noexcept {
          return m_data.cend();
      }

      const_iterator cbegin() const noexcept {
          return m_data.cbegin();
      }

      const_iterator cend() const noexcept {
          return m_data.cend();
      }

  }; // class IdSetSmall


  template <typename T, unsigned int L = 22>
  class IdSetDynamic : public IdSet<T> {

  public:

    IdSetDynamic() : m_dense_enabled(false) {}

    IdSetDynamic(const IdSetDynamic&) = default;
    IdSetDynamic& operator=(const IdSetDynamic&) = default;

    IdSetDynamic(IdSetDynamic&&) = default;
    IdSetDynamic& operator=(IdSetDynamic&&) = default;

    virtual ~IdSetDynamic() = default;

    /**
     * Add the given Id to the set.
     */
    void set(T id) {
      if (m_dense_enabled)
        m_id_set_dense.set(id);
      else
      {
        m_id_set_small.set(id);
        check_migrate_to_dense();
      }
    }

    /**
     * Is the Id in the set?
     */
    bool get(T id) const noexcept final {
      if (m_dense_enabled)
        return (m_id_set_dense.get(id));
      else
        return (m_id_set_small.get_binary_search(id));
    }

    /**
     * Is the set empty?
     */
    bool empty() const noexcept final {
      if (m_dense_enabled)
        return (m_id_set_dense.empty());
      else
        return (m_id_set_small.empty());
    }

    /**
     * Clear the set.
     */
    void clear() {
      m_id_set_dense.clear();
      m_id_set_small.clear();
    }

    /**
     * Get an estimate of the amount of memory used for the set.
     */
    std::size_t used_memory() const noexcept final {
      if (m_dense_enabled)
        return (m_id_set_dense.used_memory());
      else
        return (m_id_set_small.used_memory());
    }

    /**
     * Sorts elements in small set only
     */
    void sort_unique() {
      if (!m_dense_enabled)
        m_id_set_small.sort_unique();
    }

  private:

    void check_migrate_to_dense() {
      if (m_id_set_small.size() > 1000000) {
        for (const auto & elem : m_id_set_small)
          m_id_set_dense.set(elem);
        m_dense_enabled = true;
        m_id_set_small.clear();
      }
    }

    IdSetSmall< T >     m_id_set_small;
    IdSetDense< T, L >  m_id_set_dense;
    bool                m_dense_enabled;
  };
}


//-----------------------------------------------------------------------------

template < class Object, class TPredicateA, class TPredicateB >
class And_Predicate
{
  public:
    And_Predicate(const TPredicateA& predicate_a_, const TPredicateB& predicate_b_)
        : predicate_a(predicate_a_), predicate_b(predicate_b_) {}
    And_Predicate(TPredicateA&& predicate_a_, TPredicateB&& predicate_b_)
        : predicate_a(std::move(predicate_a_)), predicate_b(std::move(predicate_b_)) {}
    bool match(const Object& obj) const { return (predicate_a.match(obj) && predicate_b.match(obj)); }
    bool match(const Handle< Object >& h) const { return (predicate_a.match(h) && predicate_b.match(h)); }
    bool match(const Handle< Attic< Object > >& h) const { return (predicate_a.match(h) && predicate_b.match(h)); }
    bool is_time_dependent() const { return (predicate_a.is_time_dependent() || predicate_b.is_time_dependent()); }

  private:
    TPredicateA predicate_a;
    TPredicateB predicate_b;
};

template < class Object, class TPredicateA, class TPredicateB >
class Or_Predicate
{
  public:
    Or_Predicate(const TPredicateA& predicate_a_, const TPredicateB& predicate_b_)
        : predicate_a(predicate_a_), predicate_b(predicate_b_) {}
    Or_Predicate(TPredicateA&& predicate_a_, TPredicateB&& predicate_b_)
        : predicate_a(std::move(predicate_a_)), predicate_b(std::move(predicate_b_)) {}
    bool match(const Object& obj) const { return (predicate_a.match(obj) || predicate_b.match(obj)); }
    bool match(const Handle< Object >& h) const { return (predicate_a.match(h) || predicate_b.match(h)); }
    bool match(const Handle< Attic< Object > >& h) const { return (predicate_a.match(h) || predicate_b.match(h)); }
    bool is_time_dependent() const { return (predicate_a.is_time_dependent() || predicate_b.is_time_dependent()); }

  private:
    TPredicateA predicate_a;
    TPredicateB predicate_b;
};

template < class Object, class TPredicateA >
class Not_Predicate
{
  public:
    Not_Predicate(const TPredicateA& predicate_a_)
        : predicate_a(predicate_a_) {}
    Not_Predicate(TPredicateA&& predicate_a_)
        : predicate_a(std::move(predicate_a_)) {}
    bool match(const Object& obj) const { return (!predicate_a.match(obj)); }
    bool match(const Handle< Object >& h) const { return (!predicate_a.match(h)); }
    bool match(const Handle< Attic< Object > >& h) const { return (!predicate_a.match(h)); }
    bool is_time_dependent() const { return predicate_a.is_time_dependent(); }

  private:
    TPredicateA predicate_a;
};

template < class Object >
class Trivial_Predicate
{
  public:
    Trivial_Predicate() {}
    bool match(const Object& obj) const { return true; }
    bool match(const Handle< Object >& h) const { return true; }
    bool match(const Handle< Attic< Object > >& h) const { return true; }
    bool is_time_dependent() const { return false; }
};

//-----------------------------------------------------------------------------

template < class Object, unsigned int L = 16 >
class Id_Predicate
{
public:
  Id_Predicate(const std::vector< typename Object::Id_Type >& ids_) :
      dense_ids_enabled(false), ids(ids_), ids_dense { }
  {
    populate_ids_dense(ids_);
  }
  void populate_ids_dense(const std::vector< typename Object::Id_Type >& ids_) {
    if (ids_.size() >= 500000) {
      for (auto & id : ids_)
        ids_dense.set(id.val());
      dense_ids_enabled = true;
    }
  }
  bool match(const Object& obj) const
  {
    return (dense_ids_enabled ? ids_dense.get(obj.id.val()) : binary_search(ids.begin(), ids.end(), obj.id));
  }
  bool match(const Handle< Object >& h) const
  {
    return (dense_ids_enabled ? ids_dense.get(h.id().val()) : binary_search(ids.begin(), ids.end(), h.id()));
  }
  bool match(const Handle< Attic< Object > >& h) const
  {
    return (dense_ids_enabled ? ids_dense.get(h.id().val()) : binary_search(ids.begin(), ids.end(), h.id()));
  }
  bool is_time_dependent() const
  {
    return false;
  }

private:
  bool dense_ids_enabled;
  const std::vector< typename Object::Id_Type >& ids;
  experimental::IdSetDense< typename Object::Id_Type::Id_Type, L > ids_dense;
};


//-----------------------------------------------------------------------------

inline bool has_a_child_with_id
    (const Relation_Skeleton& relation, const std::vector< Uint64 >& ids, uint32 type)
{
  for (std::vector< Relation_Entry >::const_iterator it3(relation.members.begin());
      it3 != relation.members.end(); ++it3)
  {
    if (it3->type == type &&
        binary_search(ids.begin(), ids.end(), it3->ref))
      return true;
  }
  return false;
}


inline bool has_a_child_with_id_and_role
    (const Relation_Skeleton& relation, const std::vector< Uint64 >& ids, uint32 type, uint32 role_id)
{
  for (std::vector< Relation_Entry >::const_iterator it3(relation.members.begin());
      it3 != relation.members.end(); ++it3)
  {
    if (it3->type == type && it3->role == role_id &&
        binary_search(ids.begin(), ids.end(), it3->ref))
      return true;
  }
  return false;
}


inline bool has_a_child_with_id
    (const Way_Skeleton& way, const std::vector< Node::Id_Type >& ids)
{
  for (std::vector< Node::Id_Type >::const_iterator it3(way.nds.begin());
      it3 != way.nds.end(); ++it3)
  {
    if (binary_search(ids.begin(), ids.end(), *it3))
      return true;
  }
  return false;
}


class Get_Parent_Rels_Predicate
{
public:
  Get_Parent_Rels_Predicate(const std::vector< Uint64 >& ids_, uint32 child_type_)
    : ids(ids_), child_type(child_type_) {}
  bool match(const Relation_Skeleton& obj) const
  { return has_a_child_with_id(obj, ids, child_type); }
  bool match(const Handle< Relation_Skeleton >& h) const
  { return has_a_child_with_id(h.object(), ids, child_type); }
  bool match(const Handle< Attic< Relation_Skeleton > >& h) const
  { return has_a_child_with_id(h.object(), ids, child_type); }
  bool is_time_dependent() const { return true; };

private:
  const std::vector< Uint64 >& ids;
  uint32 child_type;
};


class Get_Parent_Rels_Role_Predicate
{
public:
  Get_Parent_Rels_Role_Predicate(const std::vector< Uint64 >& ids_, uint32 child_type_, uint32 role_id_)
    : ids(ids_), child_type(child_type_), role_id(role_id_) {}
  bool match(const Relation_Skeleton& obj) const
  { return has_a_child_with_id_and_role(obj, ids, child_type, role_id); }
  bool match(const Handle< Relation_Skeleton >& h) const
  { return has_a_child_with_id_and_role(h.object(), ids, child_type, role_id); }
  bool match(const Handle< Attic< Relation_Skeleton > >& h) const
  { return has_a_child_with_id_and_role(h.object(), ids, child_type, role_id); }
  bool is_time_dependent() const { return true; };

private:
  const std::vector< Uint64 >& ids;
  uint32 child_type;
  uint32 role_id;
};


class Get_Parent_Ways_Predicate
{
public:
  Get_Parent_Ways_Predicate(const std::vector< Node::Id_Type >& ids_)
    : ids(ids_) {}
  bool match(const Way_Skeleton& obj) const { return has_a_child_with_id(obj, ids); }
  bool match(const Handle< Way_Skeleton >& h) const { return has_a_child_with_id(h.object(), ids); }
  bool match(const Handle< Attic< Way_Skeleton > >& h) const { return has_a_child_with_id(h.object(), ids); }
  bool is_time_dependent() const { return true; };

private:
  const std::vector< Node::Id_Type >& ids;
};


//-----------------------------------------------------------------------------


template < typename Attic_Skeleton >
struct Attic_Comparator
{
public:
  bool operator()(const Attic_Skeleton& lhs, const Attic_Skeleton& rhs)
  {
    if (lhs.id < rhs.id)
      return true;
    if (rhs.id < lhs.id)
      return false;
    return (lhs.timestamp < rhs.timestamp);
  }
};


template < class TIndex, class TObject >
void keep_only_least_younger_than
    (std::map< TIndex, std::vector< Attic< TObject > > >& attic_result,
     std::map< TIndex, std::vector< TObject > >& result,
     uint64 timestamp)
{
  std::map< typename TObject::Id_Type, uint64 > timestamp_per_id;

  for (typename std::map< TIndex, std::vector< Attic< TObject > > >::iterator
      it = attic_result.begin(); it != attic_result.end(); ++it)
  {
    std::sort(it->second.begin(), it->second.end(), Attic_Comparator< Attic< TObject > >());
    typename std::vector< Attic< TObject > >::iterator it_from = it->second.begin();
    typename std::vector< Attic< TObject > >::iterator it_to = it->second.begin();
    while (it_from != it->second.end())
    {
      if (it_from->timestamp <= timestamp)
        ++it_from;
      else
      {
        *it_to = *it_from;
        if (timestamp_per_id[it_to->id] == 0 || timestamp_per_id[it_to->id] > it_to->timestamp)
          timestamp_per_id[it_to->id] = it_to->timestamp;
        ++it_from;
        while (it_from != it->second.end() && it_from->id == it_to->id)
          ++it_from;
        ++it_to;
      }
    }
    it->second.erase(it_to, it->second.end());
  }

  for (typename std::map< TIndex, std::vector< Attic< TObject > > >::iterator
      it = attic_result.begin(); it != attic_result.end(); ++it)
  {
    typename std::vector< Attic< TObject > >::iterator it_from = it->second.begin();
    typename std::vector< Attic< TObject > >::iterator it_to = it->second.begin();
    while (it_from != it->second.end())
    {
      if (timestamp_per_id[it_from->id] == it_from->timestamp)
      {
        *it_to = *it_from;
        ++it_to;
      }
      ++it_from;
    }
    it->second.erase(it_to, it->second.end());
  }

  for (typename std::map< TIndex, std::vector< TObject > >::iterator
      it = result.begin(); it != result.end(); ++it)
  {
    typename std::vector< TObject >::iterator it_from = it->second.begin();
    typename std::vector< TObject >::iterator it_to = it->second.begin();
    while (it_from != it->second.end())
    {
      if (timestamp_per_id.find(it_from->id) == timestamp_per_id.end())
      {
        *it_to = *it_from;
        ++it_to;
      }
      ++it_from;
    }
    it->second.erase(it_to, it->second.end());
  }
}


//-----------------------------------------------------------------------------

template < class TIndex, class TObject, class TPredicate >
void filter_items(const TPredicate& predicate, std::map< TIndex, std::vector< TObject > >& data)
{
  for (typename std::map< TIndex, std::vector< TObject > >::iterator it = data.begin();
  it != data.end(); ++it)
  {
    std::vector< TObject > local_into;
    for (typename std::vector< TObject >::const_iterator iit = it->second.begin();
    iit != it->second.end(); ++iit)
    {
      if (predicate.match(*iit))
	local_into.push_back(*iit);
    }
    it->second.swap(local_into);
  }
}

template< class TIndex, class TObject >
std::vector< typename TObject::Id_Type > filter_for_ids(const std::map< TIndex, std::vector< TObject > >& elems)
{
  std::vector< typename TObject::Id_Type > ids;
  for (typename std::map< TIndex, std::vector< TObject > >::const_iterator it = elems.begin();
  it != elems.end(); ++it)
  {
    for (typename std::vector< TObject >::const_iterator iit = it->second.begin();
    iit != it->second.end(); ++iit)
    ids.push_back(iit->id);
  }
  std::sort(ids.begin(), ids.end());

  return ids;
}

//-----------------------------------------------------------------------------


template< typename TObject >
struct Compare_By_Id
{
  bool operator()(const TObject& lhs, const TObject& rhs) { return lhs.id < rhs.id; }
};


template< class TIndex, class TObject >
bool indexed_set_union(std::map< TIndex, std::vector< TObject > >& result,
		       const std::map< TIndex, std::vector< TObject > >& summand)
{
  bool result_has_grown = false;

  for (typename std::map< TIndex, std::vector< TObject > >::const_iterator
      it = summand.begin(); it != summand.end(); ++it)
  {
    if (it->second.empty())
      continue;

    std::vector< TObject >& target = result[it->first];
    if (target.empty())
    {
      target = it->second;
      result_has_grown = true;
      continue;
    }

    if (it->second.size() == 1 && target.size() > 64)
    {
      typename std::vector< TObject >::iterator it_target
          = std::lower_bound(target.begin(), target.end(), it->second.front());
      if (it_target == target.end())
      {
        target.push_back(it->second.front());
        result_has_grown = true;
      }
      else if (!(*it_target == it->second.front()))
      {
        target.insert(it_target, it->second.front());
        result_has_grown = true;
      }
    }
    else
    {
      std::vector< TObject > other;
      other.swap(target);
      std::set_union(it->second.begin(), it->second.end(), other.begin(), other.end(),
                back_inserter(target), Compare_By_Id< TObject >());

      result_has_grown |= (target.size() > other.size());
    }
  }

  return result_has_grown;
}

//-----------------------------------------------------------------------------

template< class TIndex, class TObject >
void indexed_set_difference(std::map< TIndex, std::vector< TObject > >& result,
                            const std::map< TIndex, std::vector< TObject > >& to_substract)
{
  for (typename std::map< TIndex, std::vector< TObject > >::const_iterator
      it = to_substract.begin(); it != to_substract.end(); ++it)
  {
    std::vector< TObject > other;
    other.swap(result[it->first]);
    std::sort(other.begin(), other.end());
    std::set_difference(other.begin(), other.end(), it->second.begin(), it->second.end(),
                   back_inserter(result[it->first]));
  }
}

//-----------------------------------------------------------------------------

/* Returns for the given set of ids the set of corresponding indexes.
 * For ids where the timestamp is zero, only the current index is returned.
 * For ids where the timestamp is nonzero, all attic indexes are also returned.
 * The function requires that the ids are sorted ascending by id.
 */
template< typename Index, typename Skeleton >
std::pair< std::vector< Index >, std::vector< Index > > get_indexes
    (const std::vector< typename Skeleton::Id_Type >& ids, Resource_Manager& rman)
{
  std::pair< std::vector< Index >, std::vector< Index > > result;

  Random_File< typename Skeleton::Id_Type, Index > current(rman.get_transaction()->random_index
      (current_skeleton_file_properties< Skeleton >()));
  for (typename std::vector< typename Skeleton::Id_Type >::const_iterator
      it = ids.begin(); it != ids.end(); ++it)
    result.first.push_back(current.get(it->val()));

  std::sort(result.first.begin(), result.first.end());
  result.first.erase(std::unique(result.first.begin(), result.first.end()), result.first.end());

  if (rman.get_desired_timestamp() != NOW)
  {
    Random_File< typename Skeleton::Id_Type, Index > attic_random(rman.get_transaction()->random_index
        (attic_skeleton_file_properties< Skeleton >()));
    std::set< typename Skeleton::Id_Type > idx_list_ids;
    for (typename std::vector< typename Skeleton::Id_Type >::const_iterator
        it = ids.begin(); it != ids.end(); ++it)
    {
      if (attic_random.get(it->val()).val() == 0)
        ;
      else if (attic_random.get(it->val()) == 0xff)
        idx_list_ids.insert(it->val());
      else
        result.second.push_back(attic_random.get(it->val()));
    }

    Block_Backend< typename Skeleton::Id_Type, Index > idx_list_db
        (rman.get_transaction()->data_index(attic_idx_list_properties< Skeleton >()));
    for (typename Block_Backend< typename Skeleton::Id_Type, Index >::Discrete_Iterator
        it(idx_list_db.discrete_begin(idx_list_ids.begin(), idx_list_ids.end()));
        !(it == idx_list_db.discrete_end()); ++it)
      result.second.push_back(it.object());

    std::sort(result.second.begin(), result.second.end());
    result.second.erase(std::unique(result.second.begin(), result.second.end()), result.second.end());
  }

  return result;
}


#endif
